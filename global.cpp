#include "global.h"

extern const int SCREEN_WIDTH = 1000;
extern const int SCREEN_HEIGHT = 640;
extern const SDL_Rect SCREEN = { 0,0,SCREEN_WIDTH,SCREEN_HEIGHT };
extern SDL_Window* window = SDL_CreateWindow("Data Visualizer", 100, 100, SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_SHOWN | SDL_WINDOW_ALLOW_HIGHDPI);
extern SDL_Renderer* gRenderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);
extern TTF_Font* numberFont = NULL;
extern Theme theme = Theme::getInstance(WHITE, WHITE, BLACK, BLACK, BLACK, 30);
extern map<string, string> codeExplainMap = {
	{"ListNode* toDel = head;","Create a new Node pointer point to the head of the linked list"},
	{"head = head->next;","Set head pointer to the next Node"},
	{"delete toDel;","Delete everything in the previous head"},
	{"ListNode* curr = head->next;","Set curr pointer to the second node"},
	{"ListNode* prev = head;","Set prev pointer to the first (head) node"},
	{"while(index-- > 1){","Check exit loop if index <= 1 and decrease the index to delete"},
	{"    curr = curr->next;","Set curr pointer to the next node"},
	{"    prev = prev->next;","Set prev pointer to the next node"},
	{"prev->next = curr->next;","Set the pointer of prev to point to the next of curr pointer"},
	{"delete curr;","Deallocate the memory used by the deleted node"},
	{"    head = head->next;","Set head pointer to the next node"},
	{"ListNode* newNode = new ListNode(value,nullptr);","Create the pointer to the insert node"},
	{"newNode->next = head->next;","Set the next pointer of the insert node to next of the head pointer"},
	{"head->next = newNode;","Set the next pointer of head to point to the new node"},
	{"newNode->next = head;","Set the next pointer of the insert node to the first node (head)"},
	{"head = newNode;","Change the head pointer of linked list to the new node"},
	{"while (head){","Check if head is a nullptr,if it is then exit the loop"},
	{"    if( head->val == target )","Check to find whether the value of the pointer is equal to the target"},
	{"        return ans;","Return the index at which the value was found"},
	{"    head = head->next;","Increase the pointer to the next node"},
	{"    ans++;","Increase the answer-index of the node that has the value"},
	{"return NOT_FOUND;","If the list doesn't contain the value ,return NOT_FOUND constant (oftentimes will be -1)"},
	{"while (index--){","Check if the index variable (the index to update) is 0 or not to exit the loop, else decrease it"},
	{"head->val = updateValue;","Set the pointer value to the update value"},
	{"tail->next = newNode;","Set the next pointer of tail to point to the new node"},
	{"tail = tail->next;","Change the tail pointer to the new node"},
	{"n++;","Increase the size of array by 1"},
	{"for(int i = n-1; i > indexInsert; i--){","Check exit loop and decrease i"},
	{"    arr[i] = arr[i-1];","Set the two current element to be equal"},
	{"arr[indexInsert] = valueInsert;","Update the insert value at insert index"},
	{"for(int i = indexDelete; i < n-1; i++){","Check exit loop and increase i by 1"},
	{"    arr[i] = arr[i+1];","Set the two current element to be equal"},
	{"n--;","Decrese the size of array by 1"},
	{"for(int i=0;i<n;i++){","Check exit loop and increase i by 1"},
	{"    if(arr[i] == target){","Check if the current element value is equal to the target"},
	{"        targetIndex = i;","Set the returned value to be the current i"},
	{"        return targetIndex; }","Return the index where the value was founded"},
	{"    else continue;","Continue to the next iteration"},
	{"return NOT_FOUND;","If the array doesn't contain the value ,return NOT_FOUND constant (oftentimes will be -1)"},
	{"arr[indexUpdate] = valueUpdate;","Update the input index to be equal to the value the user input"},
	{"while (listSize--){","Check exit loop if listSize == 0 and decrease the listSize variable"},
	{"head = new ListNode(value,nullptr);","Create the head of the list"},
	{"tail->next = head;","Set tail next pointer point to head of the list because current list has only one Node to create the typical cycle"},
	{"tail = head;","Set tail pointer equal to head because list has only one node"},
	{"DLLNode* newNode = new DLLNode(value,head,head->next);","Create a new DLLNode that has prev pointer point to head pointer and next pointer point to head->next pointer"},
	{"if (head->next)    head->next->prev = newNode;","Check the next pointer existence. If it is, set its prev pointer point to the newNode "},
	{"DLLNode* newNode = new DLLNode(value,nullptr,nullptr);","Create a new DLLNode that has both prev and next pointer set to nullptr"},
	{"head->prev = newNode;","Set the prev pointer of head point to the newNode"},
	{"    toDel = toDel->next;","Increase pointer to the next Node"},
	{"if (toDel->prev)	toDel->prev->next = toDel->next;","Check the prev pointer existence. If it is, set its next to the deleteNode->next"},
	{"if (toDel->next)	toDel->next->prev = toDel->prev;","Check the next pointer existence. If it is, set its prev to the deleteNode->prev"},
	{"DLLNode* toDel = head;","Set the toDel pointer equal to head pointer"},
	{"if (head)	head->prev = nullptr;","Check the head pointer existence (the list is empty or not). If it is, set its prev to nullptr"},
	{"head = new DLLNode(value,nullptr,nullptr);","Initiate a new head that has both prev and next pointer set to nullptr"},
	{"/* Re-layout the list */","Re-layout the current list to fit the purpose of visualization"},
	{"int* newArr = new int[n+1];","Allocate the memory for the new array"},
	{"int* newArr = new int[n-1];","Allocate the memory for the new array"},
	{"for (int i = 0; i < indexInsert; i++)","Loop from 0 to indexInsert"},
	{"    newArr[i] = oldArr[i];","Move the element from the old array to the new array"},
	{"for (int i = 0; i < indexDelete; i++)","Loop from 0 to indexDelete"},
	{"for (int i = indexDelete + 1; i < n; i++)","Loop from after the index delete to the size of the old array"},
	{"    newArr[i - 1] = oldArr[i];","Move the element from the old to the new array; this time offset by -1 due to the deleted value"},
	{"arr[indexInsert] = valueInsert;","Set the index the user input to equal to the value insert"},
	{"for (int i = indexInsert + 1; i < n + 1; i++)","Loop from after the index insert to the size of the new array"},
	{"    newArr[i] = oldArr[i - 1];","Move the element from the old to the new array; this time offset by -1 due to the inserted value"},
	{"delete[] oldArr;","Free the memory allocated for the old array"},
	{"while(listSize--)","Check exit loop if listSize == 0 and decrease the listSize variable"},
	{"    stack.pop();","Delete the first node (head) of the stack"},
	{"    queue.pop();","Delete the first node (head) of the queue"},
	{"for (int i = 0; i < n; i++)","Loop from start to end of the array"},
	{"    if (arr[i] == target)","Check if the current element value is equal to the target"},
	{"        return i;","Return the index at which the value was found"}
};
